use serde::{Deserialize, Serialize};
use std::path::{Path, PathBuf};

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum AssetKind {
    #[serde(rename = "audio")]
    Audio,
    #[serde(rename = "video")]
    Video,
    #[serde(rename = "paper")]
    ScientificPaper,
    #[serde(rename = "article")]
    WrittenArticle,
    #[serde(rename = "dissertation")]
    Dissertation,
    #[serde(rename = "thesis")]
    Thesis,
    #[serde(rename = "newsletter")]
    Newsletter,
    #[serde(rename = "book")]
    Book,
    #[serde(rename = "text")]
    Text,
    #[serde(rename = "patent")]
    Patent,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AssetFrontMatterSource {
    pub series: Option<String>,
    pub title: Option<String>,
    pub url: Option<String>,
    pub mirrors: Option<Vec<String>>,
    pub kind: Option<AssetKind>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum AssetFrontMatterTranscriptionKind {
    #[serde(rename = "auto-generated")]
    AutoGenerated,
    #[serde(rename = "text")]
    Text,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AssetFrontMatterTranscription {
    pub url: Option<String>,
    pub kind: Option<AssetFrontMatterTranscriptionKind>,
    pub date: Option<String>,
    pub author: Option<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AssetFrontMatterCompletion {
    pub content: Option<bool>,

    #[serde(rename = "content-verified")]
    pub content_verified: Option<bool>,

    pub mentions: Option<bool>,
    pub issues: Option<bool>,
    pub notes: Option<bool>,
    pub timestamps: Option<bool>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AssetFrontMatterAdded {
    pub author: String,
    pub date: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AssetFrontMatter {
    pub source: AssetFrontMatterSource,
    pub transcription: Option<AssetFrontMatterTranscription>,
    pub completion: Option<AssetFrontMatterCompletion>,
    pub added: Option<AssetFrontMatterAdded>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Asset {
    pub path: PathBuf,
    pub content: String,
    pub frontmatter: Option<AssetFrontMatter>,
    pub markdown: String,
    pub date: String,
    pub slug: String,
    pub elements: crate::markdown::Element,
}

impl Asset {
    const CACHE_PATH: &str = "./cache/assets";

    pub fn to_title(&self) -> String {
        let Some(frontmatter) = self.frontmatter.as_ref() else {
            return String::default();
        };
        frontmatter.source.title.clone().unwrap_or_default()
    }

    pub fn cache_path(slug: &str) -> PathBuf {
        Path::new(Asset::CACHE_PATH).join(format!("{}.yml", slug))
    }

    #[cfg(feature = "ssr")]
    pub fn cache(&self) -> Result<(), &'static str> {
        use std::fs;
        let path = Asset::cache_path(&self.slug);
        fs::create_dir_all(path.parent().unwrap()).unwrap();
        let cache = fs::File::create(&path).map_err(|_| "Failed to create cache file")?;
        serde_yaml::to_writer(&cache, self).map_err(|_| "Failed to write to cache file")?;
        Ok(())
    }

    #[cfg(feature = "ssr")]
    pub fn try_from_cache(slug: &str) -> Result<Self, &'static str> {
        use std::fs;

        let cache_path = Asset::cache_path(slug);
        let bytes = fs::read(&cache_path).map_err(|_| "Failed to read cache")?;
        let asset = serde_yaml::from_slice(&bytes).map_err(|_| "Failed to deserialize cache")?;
        Ok(asset)
    }
}

#[cfg(feature = "ssr")]
impl TryFrom<PathBuf> for Asset {
    type Error = &'static str;

    fn try_from(path: PathBuf) -> Result<Self, Self::Error> {
        use crate::markdown::Element;

        let date_len = "0000-00-00".len();
        let stem = path
            .file_stem()
            .ok_or("Asset file has no stem")?
            .to_string_lossy()
            .to_string();
        let date = stem[..date_len].to_string();
        let slug = stem[date_len + 1..].to_string();

        if let Ok(asset) = Asset::try_from_cache(&slug) {
            return Ok(asset);
        }

        let content = std::fs::read_to_string(&path).map_err(|_| "Failed to read asset")?;
        let (frontmatter, markdown): (Option<AssetFrontMatter>, String) = {
            if content.starts_with("---") {
                if let Some(end) = content[3..].find("---") {
                    let source = &content[3..end + 3];
                    let markdown = &content[end + 6..];
                    (
                        Some(serde_yaml::from_str(source).unwrap()),
                        markdown.to_owned(),
                    )
                } else {
                    (None, content.clone())
                }
            } else {
                (None, content.clone())
            }
        };

        let parser = &mut markdown_it::MarkdownIt::new();
        markdown_it::plugins::cmark::add(parser);
        markdown_it::plugins::extra::add(parser);

        let ast = parser.parse(&markdown);
        let elements = Element::new(&ast);

        let asset = Asset {
            date,
            slug,
            content,
            path: path.into(),
            frontmatter,
            markdown,
            elements,
        };

        asset.cache().map_err(|_| "Failed to cache asset")?;

        Ok(asset)
    }
}
